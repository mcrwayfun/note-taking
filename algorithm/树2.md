# 树
## 1 二叉树遍历及其应用
### 1.1 二叉树遍历递归算法
#### 前序遍历
#### 中序遍历
#### 后序遍历

### 1.2 二叉树遍历的应用
#### 通过后序遍历计算结点数和高度
#### 通过前序遍历复制一棵二叉树
为了实现二叉树的复制方法，可以利用二叉树的前序遍历算法。若二叉树parent不为空，则首先复制根结点，这相当于二叉树前序遍历中访问根结点的语句；然后分别复制二叉树的左子树和右子树，这相当于二叉树前序遍历算法中的遍历左子树和右子树。整个算法的思想是递归。
```
	/**
     * 复制一棵二叉树
     * @param parent
     * @return
     */
    public TreeNode copy(TreeNode parent){

        if(parent == null)
            return null;

        // 构造根结点
        TreeNode temp = new TreeNode(parent.getIndex(),parent.getData());

        // 递归构造左子树
        temp.leftChild = copy(parent.leftChild);

        // 递归构造右子树
        temp.rightChild = copy(parent.rightChild);

        return temp;
    }
```
#### 判断两棵树是否相等
递归判断每个结点的`s.data == t.data`是否成立即可
```
	/**
     * 判断两棵树是否相等
     * @param s
     * @param t
     * @return
     */
    public boolean euqal(TreeNode s,TreeNode t){

        if(s == null && t == null)
            return true;

        if(s != null && t != null && s.data == t.data &&
                euqal(s.leftChild,t.leftChild) &&
                euqal(s.rightChild,t.rightChild))
            return true;
        else
            return false;
    }
```
#### 前序遍历创建二叉树
```java
 	/**
     * 前序遍历创建二叉树
     * ABD##E##CF###
     * ABDECF
     * @param data
     * @return
     */
    public TreeNode createBinaryTree(List<String> data) {

        if (data == null || data.isEmpty())
            return null;

        return createBinaryTreeHelper(data.size(), data);
    }

    private TreeNode createBinaryTreeHelper(int size, List<String> data) {

        TreeNode node;

        String d = data.get(0);
        int index = size - data.size();

        // 遇到结束符#
        if (d.equals("#")) {
            node = null;
            data.remove(0);
            return node;
        }
        node = new TreeNode(index, d);
        // 根结点
        if (index == 0) {
            root = node;
        }
        data.remove(0);
        node.leftChild = createBinaryTreeHelper(size, data);
        node.rightChild = createBinaryTreeHelper(size, data);
        return node;

    }
```
### 1.3 二叉树遍历的非递归算法
#### 利用栈进行前序遍历
![](https://i.imgur.com/vHdZahj.png)
每访问一个结点后，在向左子树遍历下去之前，利用栈来记录该结点的右子女（如果有的话），以便在左子树退回时可以直接从栈顶取得右子树的根结点，继续其右子树的遍历。上图是过程的演示，先将null压入栈中，当栈中无元素时将其推出，表示结束。
```java
	/**
     * 前序遍历非递归算法
     * output:A-B-D-E-C-F
     * @param root
     */
    public void preOrderNonRecursive(TreeNode root) {

        Stack<TreeNode> nodeStack = new Stack<>();
        nodeStack.push(null);
        while (root != null) {
            // 访问根结点
            System.out.println("preOrderNonRecursive data:" + root.getData());
            // 当前结点右子树不为空则放入栈中
            if (root.rightChild != null)
                nodeStack.push(root.rightChild);
            // 访问左子树
            if (root.leftChild != null)
                root = root.leftChild;
            else root = nodeStack.pop();
        }
    }
```
#### 利用栈进行中序遍历
从根结点开始沿着leftChild到最下角的结点，将指针依次压入栈中，直到该结点的leftChild指针为NULL。访问它的数据后，再遍历该结点的右子树。此时该结点为栈中推出的指针。
```java
 	/**
     * 中序遍历非递归算法
     * output:D-B-E-A-F-C
     * @param root
     */
    public void midOrderNonRecursive(TreeNode root) {

        Stack<TreeNode> nodeStack = new Stack<>();
        do {
            while (root != null) {
                nodeStack.push(root);
                root = root.leftChild;
            }

            if (!nodeStack.empty()) {
                root = nodeStack.pop();
                System.out.println("preOrderNonRecursive data:" + root.getData());
                root = root.rightChild;
            }
        } while (root != null || !nodeStack.empty());
    }

```